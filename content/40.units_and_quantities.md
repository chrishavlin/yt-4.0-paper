## Unitful Arrays and Quantities {#sec:units}

At a basic level, `yt` is an engine for converting data created by a simulation code into a
physically meaningful result. Attaching physical units to simulation data makes it possible to
perform dimensional analysis on the simulation data, adding additional opportunities for catching
errors in a data processing pipeline. In addition, it becomes straightforward to convert data from
one unit system to another.

In `yt` 4.0 we handle units in a an automatic fashion, with a symbolic units system. Originally part
of `yt` itself since version 3.0, the unit system has now been split off into a standalone package,
`unyt`. `unyt` leverages the symbolic math library `sympy` in combination with NumPy. In what
follows, we will refer to `unyt` when describing the unit implementation, unless we are describing a
`yt`-specific extension.

Instead of returning a NumPy `ndarray` when users query `yt` data objects for fields, we return a
`unyt_array`, a subclass of `ndarray`. `unyt_array` preserves `ndarray`'s array operations,
including deep and shallow copies, broadcasting, views, and mathematical operations. Augmenting
`ndarray`, `unyt_array` attaches unit metadata to the array data, enabling runtime checking of unit
consistency in arithmetic operations between `unyt_array` instances, and making it trivial to
compose new units using algebraic operations.

As a trivial example, when one queries a data object (here given the generic name `dd`) for the
density field, we get back a `unyt_array`, including both the simulation data for the density field,
and the units of the density field, in this case $\rm{g}/\rm{cm}^3$:

```python
>>> dd['density'] 
unyt_array([4.92e-31, 4.94e-31, 4.93e-31, ...,
            1.12e-25, 1.59e-25, 1.09e-24], 'g/cm**3')
```

One of the nicest aspects of the unit system is that the symbolic algebra for unitful operations is performed automatically by `sympy`:

```python
>>> print(dd['mass']/dd['cell_volume'])
  [4.92e-31 4.94e-31 4.93e-31 ... 
   1.12e-25 1.59e-25 1.09e-24] g/cm**3
```

`unyt_array` is primarily useful for attaching units to NumPy `ndarray` instances. For scalar data,
we have created the `unyt_quantity` class. `unyt_quantity` is a subclass of `unyt_array` with the
requirement that the "array data" associated with the instance be limited to one element.
`unyt_quantity` is primarily useful for physical constants and ensures that the units are propagated
correctly when composing quantities from arrays, physical constants, and unitless scalars:

```python
>>> from unyt import boltzmann_constant
>>> print(dd['temperature']*boltzmann_constant)
[1.28e-12 1.29e-12 1.29e-12 ... 
 1.63e-12 1.59e-12 1.40e-12] erg
```

In what follows, we will refer to both array and scalar quantities as arrays generically for the
purpose of brevity.

### Implementation {#sec:units-implementation}

The unit implementation in `unyt` is based upon the notion of dimensionality. `unyt` has 8 base
dimensions: `mass`, `length`, `time`, `temperature`, `current_mks`, `luminous_intensity`, `angle`,
and `logarithmic`. The unitless `dimensionless` dimension is also technically a base dimension,
although a trivial one. This facilitates the creation of dimensionless unit symbols to represent
quantities like metallicity that are formally dimensionless, but convenient to represent in a unit
system. We provide sympy `Symbol` objects for the base dimensions. The dimensionality of all other
units are `sympy` `Expr` objects made up of the base dimension objects and the `sympy` operation
objects `Mul` and `Pow`.

This collection of dimensions is admittedly somewhat idiosyncratic. In the SI system of units, there
is no base dimension of angle (the radian is dimensionless formally defined as meter/meter), and
there is a dimension of "amount of substance", for which the base unit is mole, but in `yt` the
`mol` unit is treated as dimensionless. The `logarithmic` dimension is a special case which will be
described in more detail below. 

For each dimension, we choose a base unit. The default base units for the first six dimensions mentioned above in `unyt` are from the SI system: kilograms, meters, seconds, kelvin, ampere, and candela. The default base unit for the `angle` dimension is radian, and the default base unit for the `logarithmic` dimension is the "neper", which is a logarithmic unit for ratios of quantities such as field strenth or power. All other units can be described as combinations of these base units along with a conversion factor to equivalent base units.

For historical and practical reasons, the default base units in `yt` itself are the "Gaussian" centimeters-grams-seconds (CGS) system, where grams and centimeters serve as the different base units for mass and length, the other base units remaining the same as SI, though formally there are no independent base units for luminous intensity or current in CGS systems. CGS was chosen for `yt` to stay consistent with the rest of the `yt` codebase prior to `yt` 3.0 and to reflect the standard practice in astrophysics. 

In any case, using a **physical** unit system makes it possible to compare quantities and arrays
produced by different datasets, possibly with different conversion factors to CGS and to code units.
We go into more detail on this point below, where we describe the different unit systems in yt. 

Let us first take some common units as examples: gram (`g`), erg (`erg`), and solar mass per cubic
megaparsec (`Msun / Mpc**3`). `g` is an "atomic" CGS base unit, `erg` is an atomic unit in CGS, but
is not a base unit, and `Msun / Mpc**3` is a combination of atomic units, which are not in CGS, and
one of them even has an SI prefix. The dimensions of `g` are `mass` and the CGS conversion factor is
1. The dimensions of `erg` are `mass * length**2 / time**2` and the CGS conversion factor is 1. The
dimensions of `Msun / Mpc**3` are `mass / length**3` and the CGS conversion factor is about $6.8
\times 10^{-41}$.

We use the `UnitRegistry` class to define all valid atomic units. All unit registries contain a unit
symbol lookup table (in a Python `dict`) containing the valid units' dimensionality and cgs
conversion factor. Here is what it would look like with the above units:

```python
{ "g":    (mass, 1.0),
  "erg":  (mass * length**2 * time**-2, 1.0),
  "Msun": (mass, 1.98892e+33),
  "pc":   (length, 3.08568e18), }
```

Note that we only define **atomic** units here. There should be no operations or SI prefixes in the
registry symbol strings. When we parse non-atomic units like `Msun/Mpc**3`, we use the registry to
look up the symbols. The unit system in `yt` knows how to handle units like `Mpc` by looking up unit
symbols with and without prefixes and modify the conversion factor appropriately.

We construct a `Unit` object by providing a string containing atomic unit symbols, combined with
operations in Python syntax, and the registry those atomic unit symbols are defined in. We use
`sympy`'s string parsing features to create the unit expression from the user-provided string.

`Unit` objects are associated with four instance members, a unit `Expression` object, a
dimensionality `Expression` object, a `UnitRegistry` instance, and a scalar conversion factor to CGS
units. These data are available for a `Unit` object by accessing the `expr`, `dimensions`,
`registry`, and `cgs_value` attributes, respectively.

`Unit` provides the methods `same_dimensions_as`, which returns True if passed a `Unit` object that
has equivalent dimensions, `get_cgs_equivalent`, which returns the equivalent cgs base units of the
`Unit`, and the `is_code_unit` property, which is `True` if the unit is composed purely of code
units and `False` otherwise. `Unit` also defines the `mul`, `div`, `pow`, and `eq` operations with
other unit objects, making it easy to compose compound units algebraically.

The `UnitRegistry` class provides the `add`, `remove`, and `modify` methods which allows users to
add, remove, and modify atomic unit definitions present in `UnitRegistry` objects. A dictionary
lookup table is also attached to the `UnitRegistry` object, providing an interface to look up unit
symbols. In general, unit registries should only be adjusted inside of a code frontend, since
otherwise quantities and arrays might be created with inconsistent unit metadata. Once a `Unit`
object is created, it will not receive updates if the original unit registry is modified.

When a `Dataset` object is instantiated, it will itself instantiate and set up a `UnitRegistry`
class that contains a full set of units that are defined for the simulation. This registry includes
not only concrete physical units like `cm` or `K`, but also unit symbols that correspond to the unit
system used internally in the simulation.

The `Dataset`-specific `UnitRegistry` also lets us encode the simulation unit system and scaling to
physical units directly into `yt`. We do this via "code units". Every `Dataset` has a `length_unit`,
`time_unit`, and `mass_unit` attributes that the user can quickly and easily query to discover the
base units of the simulation. For example:

```python
>>> import yt
>>> ds = yt.load("Enzo_64/DD0043/data0043")
>>> print(ds.length_unit)
128 Mpccm/h
>>> print(ds.quan(1.0, "code_length").in_units("Mpccm/h"))
128.0 Mpccm/h
>>> print(ds.length_unit.in_cgs())
5.555172850264421e+26 cm
```

### Handling code units {#sec:handling-code-units}

Code units are tightly coupled to on-disk parameters. To handle this, the `yt` unit system can modify, add, and remove unit symbols via the `UnitRegistry`.

Optionally, `velocity_unit`, `density_unit`, `pressure_unit`, `temperature_unit`, and `magnetic_unit` may be defined as well if the units for these fields cannot be inferred from the mass, length, and time units.

We also allow conversions to the simulation unit system. Data in code units are available by converting to `code_length`, `code_mass`, `code_time`, `code_velocity`, `code_density`, `code_magnetic`, `code_pressure`, `code_metallicity`, or any combination of those units.
Code units preserve dimensionality: an array or quantity that has units of `cm` will be convertible to `code_length`.

On-disk fields are presented in these unconverted code units. To obtain on-disk data, a user need only query a data object using an on-disk field name:

```python
>>> import yt
>>> ds = yt.load("Enzo_64/DD0043/data0043")
>>> dd = ds.all_data()
>>> print(dd["enzo", "Density"])
[6.74e-02 6.12e-02 8.92e-02 ... 
 9.09e+01 5.66e+01 4.27e+01] code_mass/code_length**3
>>> print(dd["gas", "density"])
[1.92e-31 1.74e-31 2.54e-31 ... 
 2.59e-28 1.61e-28 1.22e-28] g/cm**3
```

Here, the first data object query is returned in code units, while the second is returned in CGS units.
This is because `("enzo", "Density")` is an on-disk field, while `("gas", "density")` is an internal `yt` field, aliased to the former. 

#### Associating arrays with a coordinate system {#sec:associating-arrays-with-a-coordinate-system}

To create quantities and arrays in units defined by a simulation coordinate system, we associate a `UnitRegistry` instance with `Dataset` instances.
This unit registry contains the metadata necessary to convert the array to CGS from some other known unit system and is available via the `unit_registry` attribute that is attached to all `Dataset` instances.

In the `set_code_units` method of the `Dataset` base class, the predefined `code_mass`, `code_length`, `code_time`, `code_velocity`, and `code_magnetic` symbols are adjusted to the appropriate values, and `length_unit`, `time_unit`, `mass_unit`, `velocity_unit`, and `magnetic_unit` attributes are attached to the `Dataset` instance. If there are frontend-specific code units, they should also be defined in subclasses by extending this function.

### Handling cosmological units {#sec:handling-cosmological-units}

A special case of astrophysical hydrodynamical simulations are cosmological simulations, which attempt to simulate the evolution of structure on cosmological length and time scales. Such simulations use "comoving coordinates", which is a notion of length that does not change with the expansion of the universe, in contrast to normal physical distances which do. 

If we detect that we are loading a cosmological simulation performed in comoving coordinates, extra comoving units are added to the dataset's unit registry. Comoving length unit symbols are still named following the pattern `<length symbol>cm`, i.e. `Mpccm`. The $h$ symbol is treated as a base unit, `h`, which defaults to unity. The `Dataset.set_units` method updates the `h` symbol to the correct value when loading a cosmological simulation.

The change of physical length is illustrated by the following example, of two datasets from the same simulation but at different times/scale factors/redshifts:

```python
>>> import yt
>>> ds1 = yt.load('Enzo_64/DD0002/data0002')
>>> ds2 = yt.load('Enzo_64/DD0043/data0043')
>>> print(ds1.length_unit, ds2.length_unit)
128 Mpccm/h, 128 Mpccm/h
>>> print(ds1.length_unit.in_cgs())
6.26145538088e+25 cm
>>> print(ds2.length_unit.in_cgs())
5.55517285026e+26 cm 
```

### Unit systems {#sec:unit-systems}

### Unit conversions {#sec:unit-conversions}

Aside from the ability to carry units through calculations, the other basic need for having a units implementation in `yt` is to be able to perform conversions of arrays from one unit to another of the same dimension. Creating a new array or quantity from an existing one can be done using the `in_units` method (or the `to` method, which is a convenient alias):

```python
>>> import yt 
>>> ds = yt.load("GasSloshing/sloshing_nomag2_hdf5_plt_cnt_0100")
>>> sp = ds.sphere("c", (100.0, "kpc"))
>>> print(sp["gas","velocity_x"])
[-4793397.  -5297494.5 -4997635.  ... 10608344.  10382381.  10529207. ] cm/s
>>> print(sp["gas","velocity_x"].in_units("mile/hr"))
[-107225.23711525 -118501.57704009 -111793.91105941 ...  237301.89692198
  232247.24856836  235531.65264853] mile/hr
>>> print(sp["gas","pressure"])
[1.62223415e-10 1.60880725e-10 1.62334618e-10 ... 1.54101079e-10
 1.52756530e-10 1.53220436e-10] dyn/cm**2
>>> print(sp["gas","pressure"].to("J/m**3"))
[1.62223415e-11 1.60880725e-11 1.62334618e-11 ... 1.54101079e-11
 1.52756530e-11 1.53220436e-11] J/m**3
```

To convert an array in-place instead of making a copy, use `convert_to_units`:

```python
>>> momentum_y = sp["gas","mass"]*sp["gas","velocity_y"]
>>> print(momentum_y)
[1.45031068e+47 1.40467746e+47 1.42059875e+47 ... 1.01206589e+47
 9.94539437e+46 1.06969711e+47] cm*g/s
>>> momentum_y.convert_to_units("Msun*kpc/Myr")
>>> print(momentum_y)
[745945.76032301 722474.98923595 730663.86660289 ... 520541.05697294
 511526.58818102 550182.82006007] Msun*kpc/Myr
```

Naturally, attempting to convert an array to units with a different dimension raises an error (in most cases, see below for exceptions):

```python
>>> print(momentum_y.to("degC"))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jzuhone/mambaforge/envs/py311/lib/python3.11/site-packages/unyt/array.py", line 947, in to
    return self.in_units(units, equivalence=equivalence, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/jzuhone/mambaforge/envs/py311/lib/python3.11/site-packages/unyt/array.py", line 874, in in_units
    (conversion_factor, offset) = self.units.get_conversion_factor(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/jzuhone/mambaforge/envs/py311/lib/python3.11/site-packages/unyt/unit_object.py", line 694, in get_conversion_factor
    return _get_conversion_factor(self, other_units, dtype)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/jzuhone/mambaforge/envs/py311/lib/python3.11/site-packages/unyt/unit_object.py", line 939, in _get_conversion_factor
    raise UnitConversionError(
unyt.exceptions.UnitConversionError: Cannot convert between 'Msun*kpc/Myr' (dim '(length)*(mass)/(time)') and '°C' (dim '(temperature)').
```

#### Equivalencies {#sec:equivalencies}

In certain circumstances, conversion from one quantity to another with different dimensions is
desired. This is the case for a number of frequently encountered, physically-motivated
transformations which involve physical constants, some examples of which are:

* Conversions between temperature and energy via $E = k_BT$
* Conversions between wavelength, frequency, and energy for light via $E = h\nu = hc/\lambda$
* Conversions between mass and energy via $E = mc^2$
* Conversions between density and number density via $n = \rho/({\mu}m_p)$

As described above, conversions between quantities in different units is generally not allowed, but these special cases can be handled using unit equivalencies in `yt`. This is done using the `to_equivalent` method, which takes the unit in a different dimension that you want to convert to, and the equivalence you would like to use: 

```python
>>> import unyt as u
>>> kT = 5.0*u.keV
>>> # converting kT (energy) to T (temperature)
>>> print(kT.to_equivalent("K", "thermal"))
34813557.843240075 K
>>> # converting kT (energy) to Angstrom (wavelength)
>>> print(kT.to_equivalent("angstrom", "spectral"))
4.132806438406553 Å
>>> # print the proton's compton wavelength in picometers 
>>> print(u.mp.to_equivalent("pm", "compton"))
0.00132141 pm
```

These equivalencies are straightforward--in the case of others, more information may be required. For example, to convert temperature to sound speed via $c_s = \sqrt{\gamma{k_BT}/(\mu{m_p})}$, there are two parameters which may be optionally changed, $\gamma$ and $\mu$, which are the ratio of specific heats and the mean molecular weight, respectively:

```python
>>> import unyt as u
>>> T = 1.0e6*u.K
>>> # default gamma = 5/3 and mu = 0.6
>>> print(T.to_equivalent("km/s", "sound_speed"))
151.372499274441 km/s
>>> print(T.to_equivalent("km/s", "sound_speed", mu=1.0))
117.25263375274085 km/s
>>> print(T.to_equivalent("km/s", "sound_speed", gamma=4./3.))
135.39167932067505 km/s
```

For convenience, the same operations can actually be carried out simply using the `to` method described above:

```python
>>> import unyt as u
>>> kT = 5.0*u.keV
>>> print(kT.to("K", "thermal"))
34813557.843240075 K
>>> T = 1.0e6*u.K
>>> print(T.to("km/s", "sound_speed", gamma=4./3.))
135.39167932067505 km/s
```

#### Conversions between electromagnetic units in different systems

Conversions between different electromagnetic units require special handling in many cases. The reason for this is that the units for many electromagnetic quantities do not have the same dimensions between the Gaussian CGS and the SI unit systems. For illustration, let us consider the units of magnetic field strength. Superficially, it would appear that there is a simple conversion between the cgs units of gauss ($\rm{G}$) and the SI units of tesla ($\rm{T}$), since numerically $1~\rm{G} = 10^{-4}~\rm{T}$. However, if we examine the base units, we find that they have different dimensions:

$$
\mathrm{CGS:} 1~\mathrm{G} = 1~\frac{\sqrt{\mathrm{g}}}{\sqrt{\mathrm{cm}}\cdot\mathrm{s}} \\
\mathrm{SI:} 1~\mathrm{T} = 1~\frac{\mathrm{kg}}{\mathrm{A}\cdot{\mathrm{s}}}
$$

The reason for this has already been noted above: the SI system has a base unit of current (the ampere), and all other electromagnetic units in SI are derived from it and combinations of other units. `unyt` handles conversions between electromagnetic quantities with _atomic_ units between CGS and SI systems, under the hood despite this difference:

```python
>>> import unyt as u
>>> I = 10.0*u.A
>>> print(I.units.dimensions)
(current_mks)
>>> Icgs = I.to("statA")
>>> print(Icgs)
2997924580.0 statA
>>> print(Icgs.units.dimensions)
(length)**(3/2)*sqrt((mass))/(time)**2
>>> B = 1.0e-4*u.T
>>> print(B.units.dimensions)
(mass)/((current_mks)*(time)**2)
>>> Bcgs = B.to("G")
>>> print(Bcgs)
1.0 G
>>> print(Bcgs.units.dimensions)
sqrt((mass))/(sqrt((length))*(time))
>>> Vcgs = 1.0*u.statV
>>> print(Vcgs.units.dimensions)
sqrt((length))*sqrt((mass))/(time)
>>> Vsi = Vcgs.to("V")
>>> print(Vsi)
0.0033356409519815205 V
>>> print(Vsi.units.dimensions)
(length)**2*(mass)/((current_mks)*(time)**3)
```

Because it is more difficult to handle non-atomic conversions easily, these will still raise errors:

```python
>>> import unyt as u
>>> # 3D current density in SI units
>>> J = 1.0*u.A/u.m**3 
>>> # attempt to convert to the same quantity in Gaussian CGS units
>>> print(J.to("statA/cm**3"))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jzuhone/mambaforge/envs/py311/lib/python3.11/site-packages/unyt/array.py", line 947, in to
    return self.in_units(units, equivalence=equivalence, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/jzuhone/mambaforge/envs/py311/lib/python3.11/site-packages/unyt/array.py", line 874, in in_units
    (conversion_factor, offset) = self.units.get_conversion_factor(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/jzuhone/mambaforge/envs/py311/lib/python3.11/site-packages/unyt/unit_object.py", line 694, in get_conversion_factor
    return _get_conversion_factor(self, other_units, dtype)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/jzuhone/mambaforge/envs/py311/lib/python3.11/site-packages/unyt/unit_object.py", line 939, in _get_conversion_factor
    raise UnitConversionError(
unyt.exceptions.UnitConversionError: Cannot convert between 'A/m**3' (dim '(current_mks)/(length)**3') and 'statA/cm**3' (dim 'sqrt((mass))/((length)**(3/2)*(time)**2)').
```

For these cases, it is recommended to convert atomic electromagnetic units separately first in equations, if necessary.

### Creating unyt_array and unyt_quantity instances {#sec:creating-ytarray-and-ytquantity-instances}

Aside from converting an array to new units as described above, there are two further ways to create new array and quantity objects: via a constructor, and by multiplying scalar data by a unit quantity.

#### Class Constructor {#sec:class-constructor}

The primary internal interface for creating new arrays and quantities is through the class
constructor for `unyt_array`. The constructor takes three arguments. The first argument is the input
data, which can be an integer, float, list, or array. The second argument, `input_units`, is a unit
specification which must be a string or `Unit` instance. Last, users may optionally supply a
`UnitRegistry` instance, which will be attached to the array. If no `UnitRegistry` is supplied, a
default unit registry is used instead. Unit specification strings must be algebraic combinations of
unit symbol names, using standard Python mathematical syntax (i.e. `**` for the power function, not
`^`).

Here is a simple example of `unyt_array` creation:

```python
>>> from unyt import unyt_array, unyt_quantity 
>>> unyt_array([1, 2, 3], 'cm') 
unyt_array([1, 2, 3]) cm
>>> unyt_quantity(3, 'J') 
unyt_quantity(3, 'J') 
```

In addition to the class constructor, we have also defined two convenience functions, `quan`, and
`arr`, for quantity and array creation that are attached to the `Dataset` base class. These were
added to syntactically simplify the creation of arrays with the `UnitRegistry` instance associated
with a dataset. These functions work exactly like the `unyt_array` and `unyt_quantity` constructors,
but pass the `UnitRegistry` instance attached to the dataset to the underlying constructor call. For
example:

```python
>>> import yt
>>> ds = yt.load("Enzo_64/DD0043/data0043")
>>> ds.arr([1, 2, 3], 'code_length').in_cgs() 
unyt_array([5.55e+26, 1.11e+27, 1.66e+27], 'cm')
```

This example illustrates that the array is being created using `ds.unit_registry`, rather than the `default_unit_registry` in `yt`.

#### Multiplication {#sec:multiplication}

New `unyt_array` and `unyt_quantity` instances can also be created by multiplying `unyt_array`, `unyt_quantity`, or `Unit` instances by `float` or `ndarray` instances. 
To make it easier to create arrays using this mechanism, we have populated the `unyt` namespace with predefined `Unit` instances that correspond to common unit symbol names.
For example:

```python
>>> from unyt import meter, gram, kilogram, second, joule 
>>> kilogram * meter**2 == joule 
True
>>> from unyt import m, kg, s, W 
>>> kg*m**2/s**3 == W
True

>>> from unyt import kilometer 
>>> three_kilometers = 3*kilometer 
>>> print(three_kilometers)
3.0 km

>>> from unyt import gram, kilogram 
>>> my_g = 1.0*gram
>>> my_kg = 1.0*kilogram
>>> print(my_g+my_kg)
1001.0 g 
>>> print(my_kg+my_g)
1.001 kg 
>>> print(my_kg/my_g)
1000.0 dimensionless
```

### Importing and exporting units {#sec:importing-exporting-units}

